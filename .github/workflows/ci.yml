name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.21'

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
          args: --timeout=5m
      
      - name: Go Format Check
        run: |
          if [ -n "$(gofmt -l .)" ]; then
            echo "Go code is not formatted:"
            gofmt -d .
            exit 1
          fi
      
      - name: Go Vet
        run: go vet ./...

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Get dependencies
        run: |
          go mod download
          go mod tidy
      
      - name: Run Unit Tests
        run: |
          go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...
      
      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.txt
          flags: unittests
          name: codecov-umbrella

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: lint
    services:
      sqlite:
        image: nouchka/sqlite3:latest
        options: >-
          --health-cmd "sqlite3 --version"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Get dependencies
        run: go mod download
      
      - name: Build Binary
        run: go build -o io .
      
      - name: Create test config
        run: |
          cat > config.yaml << EOF
          storage:
            path: ./test-storage
            database: ./test-storage.db
          api:
            port: "8080"
            key: "test-api-key"
            mode: "hybrid"
          s3:
            enabled: true
            port: "9000"
            access_key: "minioadmin"
            secret_key: "minioadmin"
            region: "us-east-1"
          EOF
      
      - name: Start IO Service
        run: |
          export IO_API_KEY="test-api-key"
          ./io &
          sleep 5
      
      - name: Test Native API
        run: |
          # Test health
          curl -f http://localhost:8080/api/exists/test -H "X-API-Key: test-api-key" || exit 1
          
          # Test upload
          echo "test content" > test.txt
          RESPONSE=$(curl -s -X POST http://localhost:8080/api/store \
            -H "X-API-Key: test-api-key" \
            -F "file=@test.txt")
          SHA1=$(echo $RESPONSE | grep -o '"sha1":"[^"]*' | cut -d'"' -f4)
          echo "Uploaded file SHA1: $SHA1"
          
          # Test download
          curl -f http://localhost:8080/api/file/$SHA1 \
            -H "X-API-Key: test-api-key" \
            -o downloaded.txt
          
          # Verify content
          if ! diff test.txt downloaded.txt; then
            echo "Downloaded content doesn't match!"
            exit 1
          fi
      
      - name: Test S3 API
        run: |
          # Create bucket
          curl -X PUT http://localhost:9000/test-bucket
          
          # Upload object
          curl -X PUT http://localhost:9000/test-bucket/test-key \
            -d "S3 test content"
          
          # Get object
          curl -f http://localhost:9000/test-bucket/test-key -o s3-download.txt
          
          # List objects
          curl -f http://localhost:9000/test-bucket
      
      - name: Run Advanced S3 Tests
        run: |
          # Convert test file to regular Go test
          mv test_s3_advanced.go test_s3_advanced_test.go 2>/dev/null || true
          go test -v -run TestS3Advanced ./...

  build:
    name: Build Binary
    runs-on: ubuntu-latest
    needs: [test, integration-test]
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Build
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          OUTPUT_NAME=io-${{ matrix.goos }}-${{ matrix.goarch }}
          if [ "${{ matrix.goos }}" = "windows" ]; then
            OUTPUT_NAME=${OUTPUT_NAME}.exe
          fi
          go build -v -o ${OUTPUT_NAME} .
      
      - name: Upload Artifact
        uses: actions/upload-artifact@v3
        with:
          name: io-${{ matrix.goos }}-${{ matrix.goarch }}
          path: io-*

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v3
      
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body_path: ./RELEASE_NOTES.md
          draft: false
          prerelease: false
      
      - name: Upload Release Assets
        run: |
          for file in io-*/io-*; do
            asset_name=$(basename $file)
            echo "Uploading $asset_name"
            gh release upload ${{ github.ref_name }} "$file" \
              --clobber \
              --repo ${{ github.repository }}
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [test, integration-test]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ secrets.DOCKER_USERNAME }}/io
            ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max